#!/usr/bin/env python3
"""
ZIP文件批量解压模块 - 同目录解压版
使用系统unzip命令和多进程处理优化性能
直接将ZIP文件解压到同目录下，不创建子文件夹
"""

import os
import sys
import logging
import subprocess
import time
import shutil
from pathlib import Path
from concurrent.futures import ProcessPoolExecutor, as_completed
from typing import List, Tuple, Optional, Dict

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('zip_extractor.log')
    ]
)
logger = logging.getLogger(__name__)


class ZipExtractor:
    """使用unzip和多进程的ZIP解压器（同目录解压版）"""
    
    def __init__(self, max_workers: Optional[int] = None, timeout: int = 300):
        """
        初始化解压器
        
        Args:
            max_workers: 最大工作进程数，默认为CPU核心数
            timeout: 单个解压任务超时时间（秒）
        """
        self.max_workers = max_workers or os.cpu_count()
        self.timeout = timeout
        self._check_unzip_available()
        
    def _check_unzip_available(self) -> None:
        """检查系统是否安装了unzip命令"""
        try:
            result = subprocess.run(
                ['which', 'unzip'],
                capture_output=True,
                text=True,
                check=True
            )
            logger.info(f"unzip命令可用: {result.stdout.strip()}")
        except subprocess.CalledProcessError:
            logger.error("系统未安装unzip命令，请先安装: sudo apt-get install unzip")
            raise RuntimeError("unzip命令不可用")
    
    def extract_zip(self, zip_path: Path) -> Tuple[bool, str]:
        """
        解压单个ZIP文件到同目录
        
        Args:
            zip_path: ZIP文件路径
            
        Returns:
            (成功标志, 错误信息)
        """
        try:
            # 检查ZIP文件是否存在
            if not zip_path.exists():
                error_msg = f"ZIP文件不存在: {zip_path}"
                logger.error(error_msg)
                return False, error_msg
            
            # 检查目录写入权限
            if not os.access(zip_path.parent, os.W_OK):
                error_msg = f"无写入权限: {zip_path.parent}"
                logger.error(error_msg)
                return False, error_msg
            
            # 使用unzip命令解压到同目录
            cmd = [
                'unzip',
                '-o',  # 覆盖已存在文件
                '-q',  # 安静模式，减少输出
                str(zip_path),
                '-d', str(zip_path.parent)  # 解压到ZIP文件所在目录
            ]
            
            logger.info(f"开始解压: {zip_path.name}")
            start_time = time.time()
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            duration = time.time() - start_time
            
            if result.returncode != 0:
                error_msg = f"解压失败: {zip_path.name} - {result.stderr}"
                logger.error(error_msg)
                return False, error_msg
            
            logger.info(f"解压完成: {zip_path.name} (耗时: {duration:.2f}s)")
            return True, ""
            
        except subprocess.TimeoutExpired:
            error_msg = f"解压超时: {zip_path.name}"
            logger.error(error_msg)
            return False, error_msg
        except Exception as e:
            error_msg = f"解压异常: {zip_path.name} - {str(e)}"
            logger.error(error_msg)
            return False, error_msg
    
    def process_nested_zips(self, directory: Path) -> int:
        """
        处理嵌套的ZIP文件
        
        Args:
            directory: 要搜索的目录
            
        Returns:
            处理的嵌套ZIP文件数量
        """
        nested_zips = list(directory.glob("*.zip"))  # 只在当前目录查找，不递归
        processed_count = 0
        
        for nested_zip in nested_zips:
            success, error = self.extract_zip(nested_zip)
            
            if success:
                try:
                    os.remove(nested_zip)
                    logger.info(f"已删除嵌套ZIP: {nested_zip.name}")
                    processed_count += 1
                except OSError as e:
                    logger.warning(f"无法删除嵌套ZIP: {nested_zip.name} - {str(e)}")
            else:
                logger.warning(f"嵌套ZIP解压失败: {nested_zip.name} - {error}")
        
        return processed_count
    
    def process_single_zip(self, zip_file: Path, delete_original: bool = True) -> bool:
        """
        处理单个ZIP文件（包括解压和处理嵌套ZIP）
        
        Args:
            zip_file: ZIP文件路径
            delete_original: 是否删除原始ZIP文件
            
        Returns:
            处理是否成功
        """
        # 解压ZIP文件到同目录
        success, error = self.extract_zip(zip_file)
        
        if not success:
            return False
        
        # 处理嵌套ZIP文件（在当前目录中查找）
        nested_count = self.process_nested_zips(zip_file.parent)
        if nested_count > 0:
            logger.info(f"处理了 {nested_count} 个嵌套ZIP文件: {zip_file.name}")
        
        # 删除原始ZIP文件
        if delete_original:
            try:
                os.remove(zip_file)
                logger.info(f"已删除原始ZIP: {zip_file.name}")
            except OSError as e:
                logger.warning(f"无法删除原始ZIP: {zip_file.name} - {str(e)}")
        
        return True
    
    def batch_extract(self, zip_dir: Path, delete_original: bool = True) -> dict:
        """
        批量解压ZIP文件
        
        Args:
            zip_dir: 包含ZIP文件的目录
            delete_original: 是否删除原始ZIP文件
            
        Returns:
            处理结果统计
        """
        # 检查目录权限
        if not os.access(zip_dir, os.R_OK):
            raise PermissionError(f"无读取权限: {zip_dir}")
        
        if not os.access(zip_dir, os.W_OK):
            raise PermissionError(f"无写入权限: {zip_dir}")
        
        # 获取所有ZIP文件
        zip_files = list(zip_dir.glob("*.zip"))
        total_count = len(zip_files)
        
        if total_count == 0:
            logger.warning(f"未找到ZIP文件: {zip_dir}")
            return {"total": 0, "success": 0, "failed": 0}
        
        logger.info(f"找到 {total_count} 个ZIP文件，开始处理...")
        
        # 使用多进程并行处理
        success_count = 0
        failed_files = []
        
        with ProcessPoolExecutor(max_workers=self.max_workers) as executor:
            # 提交所有任务
            future_to_file = {
                executor.submit(
                    self.process_single_zip, 
                    zip_file, 
                    delete_original
                ): zip_file for zip_file in zip_files
            }
            
            # 处理结果
            for future in as_completed(future_to_file):
                zip_file = future_to_file[future]
                try:
                    success = future.result()
                    if success:
                        success_count += 1
                    else:
                        failed_files.append(zip_file.name)
                except Exception as e:
                    logger.error(f"处理异常: {zip_file.name} - {str(e)}")
                    failed_files.append(zip_file.name)
        
        # 输出统计结果
        logger.info(f"处理完成: 成功 {success_count}/{total_count}, 失败 {len(failed_files)}")
        
        if failed_files:
            logger.warning(f"失败文件列表: {failed_files}")
        
        return {
            "total": total_count,
            "success": success_count,
            "failed": len(failed_files),
            "failed_files": failed_files
        }
    
    def extract_with_backup(self, zip_dir: Path, backup_dir: Optional[Path] = None) -> dict:
        """
        带备份的批量解压
        
        Args:
            zip_dir: 包含ZIP文件的目录
            backup_dir: 备份目录，如果为None则不备份
            
        Returns:
            处理结果统计
        """
        # 创建备份目录
        if backup_dir:
            os.makedirs(backup_dir, exist_ok=True)
        
        # 获取所有ZIP文件
        zip_files = list(zip_dir.glob("*.zip"))
        total_count = len(zip_files)
        
        if total_count == 0:
            logger.warning(f"未找到ZIP文件: {zip_dir}")
            return {"total": 0, "success": 0, "failed": 0}
        
        logger.info(f"找到 {total_count} 个ZIP文件，开始处理...")
        
        # 使用多进程并行处理
        success_count = 0
        failed_files = []
        
        with ProcessPoolExecutor(max_workers=self.max_workers) as executor:
            # 提交所有任务
            future_to_file = {}
            for zip_file in zip_files:
                # 备份ZIP文件
                if backup_dir:
                    backup_path = backup_dir / zip_file.name
                    try:
                        shutil.copy2(zip_file, backup_path)
                        logger.info(f"已备份: {zip_file.name}")
                    except Exception as e:
                        logger.error(f"备份失败: {zip_file.name} - {str(e)}")
                        failed_files.append(zip_file.name)
                        continue
                
                future = executor.submit(
                    self.process_single_zip, 
                    zip_file, 
                    True  # 删除原始文件
                )
                future_to_file[future] = zip_file
            
            # 处理结果
            for future in as_completed(future_to_file):
                zip_file = future_to_file[future]
                try:
                    success = future.result()
                    if success:
                        success_count += 1
                    else:
                        failed_files.append(zip_file.name)
                except Exception as e:
                    logger.error(f"处理异常: {zip_file.name} - {str(e)}")
                    failed_files.append(zip_file.name)
        
        # 输出统计结果
        logger.info(f"处理完成: 成功 {success_count}/{total_count}, 失败 {len(failed_files)}")
        
        if failed_files:
            logger.warning(f
